// Generated by CoffeeScript 1.6.3
var Board,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Board = (function(_super) {
  __extends(Board, _super);

  function Board(parent, data_bus) {
    var _this = this;
    this.parent = parent;
    this.data_bus = data_bus;
    this.game_players = null;
    this.game_score = {
      "black": 0,
      "white": 0
    };
    this.board = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]];
    this.last_board = this.board;
    this.register_commands = ["player_move", "player_move_confirm"];
    this.register_variables = {
      "game_score": function() {
        return _this.game_score;
      }
    };
    this.register_events = {
      "player_move": [],
      "player_move_confirm": []
    };
    this.messages = {
      "null": null
    };
    Board.__super__.constructor.call(this, "board");
    this.board_image = $("<img id='board_image' src='img/board.gif'>");
    this.board_click_layer = $("<div id='board_click_layer'>").click(function(e) {
      return _this.local_move(e.pageX, e.pageY);
    });
    this.main_element.append(this.board_click_layer).append(this.board_image);
    this.data_bus.databus_subscribe_to_event("end_game_display", this);
    return;
  }

  Board.prototype.init = function() {
    this.game_players = this.data_bus.databus_request_variable("game_players");
    this.do_move(3, 3, "white");
    this.do_move(4, 3, "black");
    this.do_move(3, 4, "black");
    this.do_move(4, 4, "white");
  };

  Board.prototype.receive_command = function(command, value) {
    var c, captures, move_x, move_y, _i, _len;
    if (command === "player_move") {
      move_x = value.x;
      move_y = value.y;
      captures = this.get_captures([move_x, move_y], this.game_players.opponent.color);
      for (_i = 0, _len = captures.length; _i < _len; _i++) {
        c = captures[_i];
        this.do_move(c[0], c[1], this.game_players.opponent.color);
      }
      this.do_move(move_x, move_y, this.game_players.opponent.color);
      this.count_score();
      this.raise_event("player_move", value);
    } else if (command === "player_move_confirm") {
      if (value["error"] !== 0) {
        this.rollback();
        return;
      }
      this.count_score();
      this.raise_event("player_move_confirm", value);
    }
  };

  Board.prototype.event_notify = function(event_name) {
    if (event_name === "end_game_display") {
      return this.deactivate_board();
    }
  };

  Board.prototype.deactivate_board = function() {
    this.board_click_layer.unbind("click");
    this.board_click_layer.click(false);
  };

  Board.prototype.rollback = function() {
    this.count_score();
  };

  Board.prototype.count_score = function() {
    var black, row, white, x, y;
    black = 0;
    white = 0;
    for (y in this.board) {
      row = this.board[y];
      for (x in row) {
        if (row[x] !== 0) {
          if (row[x].hasClass("black")) {
            black++;
          } else {
            white++;
          }
        }
      }
    }
    this.game_score.black = black;
    this.game_score.white = white;
  };

  Board.prototype.local_move = function(x, y) {
    var c, captures, coords, turn, turn_color, _i, _len;
    turn = this.data_bus.databus_request_variable("game_turn");
    console.log("TURN IS", turn);
    if (turn !== "local") {
      return;
    }
    coords = this.element_to_board_coordinates(x, y);
    if (this.board[coords[1]][coords[0]] !== 0) {
      return;
    }
    turn_color = this.game_players[turn].color;
    captures = this.get_captures(coords, turn_color);
    if (captures.length === 0) {
      return;
    }
    this.do_move(coords[0], coords[1], turn_color);
    for (_i = 0, _len = captures.length; _i < _len; _i++) {
      c = captures[_i];
      this.do_move(c[0], c[1], turn_color);
    }
    this.send_command({
      "player_move": {
        "x": coords[0],
        "y": coords[1]
      }
    });
    this.count_score();
    this.raise_event("player_move");
  };

  Board.prototype.element_to_board_coordinates = function(x, y) {
    var board_x, board_y;
    board_x = Math.floor(x / (this.board_image.width() / 8));
    board_y = Math.floor(y / (this.board_image.height() / 8));
    return [board_x, board_y];
  };

  Board.prototype.board_to_element_coordinates = function(x, y) {
    return [x * (this.board_image[0].width / 8) - 10 + 1 * x, y * (this.board_image[0].width / 8) - 10 + 1 * y];
  };

  Board.prototype.do_move = function(x, y, color) {
    var coords, element_x, element_y, piece;
    console.log("Do move", x, y);
    coords = this.board_to_element_coordinates(x, y);
    piece = $("<img class='board_piece " + color + "'>");
    piece.attr("src", "img/" + color + ".png");
    element_x = coords[0];
    element_y = coords[1];
    piece.css({
      "left": "" + element_x + "px",
      "top": "" + element_y + "px",
      "width": "21%",
      "height": "auto"
    });
    this.main_element.append(piece);
    this.last_board = this.board;
    if (this.board[y][x] !== 0) {
      this.board[y][x].remove();
    }
    this.board[y][x] = piece;
  };

  Board.prototype.get_captures = function(board_coordinates, turn_color) {
    var add_x, add_y, c, capturable, captured, counter, current_piece, dir_x, dir_y, i, j, move_x, move_y, opponent_color, x, y;
    if (turn_color === "black") {
      opponent_color = "white";
    } else {
      opponent_color = "black";
    }
    x = board_coordinates[0];
    y = board_coordinates[1];
    captured = [];
    move_x = move_y = [-1, 0, 1];
    for (i in move_x) {
      for (j in move_y) {
        dir_x = move_x[i];
        dir_y = move_y[j];
        if (dir_x === 0 && dir_y === 0) {
          continue;
        }
        capturable = [];
        current_piece = null;
        counter = 1;
        while (counter < 8) {
          add_x = x + dir_x * counter;
          add_y = y + dir_y * counter;
          if (add_x > 7 || add_x < 0 || add_y > 7 || add_y < 0) {
            break;
          }
          current_piece = this.board[add_y][add_x];
          if (current_piece !== 0 && current_piece.hasClass(opponent_color)) {
            capturable[capturable.length] = [add_x, add_y];
          } else {
            break;
          }
          counter++;
        }
        if (!current_piece || current_piece === 0 || !current_piece.hasClass(turn_color)) {
          continue;
        }
        for (c in capturable) {
          captured[captured.length] = capturable[c];
        }
      }
    }
    return captured;
  };

  return Board;

})(View);
